
import { DeckYjsAdapter } from './deckYjsService';
import { SlideStyleType, ElementType } from '../deck-editor';

/**
 * PAULUS.AI â€” RESTORE DECK OUTPUT ADAPTER (CANONICAL)
 * 
 * Single bridge between upstream modules and the Deck.
 * Fulfills MASTER CONTRACT rules for deterministic Deck updates.
 */

export interface ModulePayload {
  text?: string;
  texts?: string[];
  imageUrl?: string;
  images?: string[];
  meta?: Record<string, any>;
}

export interface ContentPatch {
  elementId: string;
  value: any;
  type: 'TEXT' | 'IMAGE';
}

export class DeckOutputAdapter {
  constructor(private yjs: DeckYjsAdapter) {}

  /**
   * Intent: Create a new slide from a specific module.
   * Logic: Appends to DeckDoc using canonical spawnElements() logic and fills skeleton slots.
   */
  public async createSlideFromModule(params: {
    sourceModule: 'CLIENT_BRIEF' | 'STRATEGY_RESEARCH' | 'CREATIVE_IDEATION' | 'COPY_SCRIPT' | 'STORYBOARD' | 'DIRECTION';
    slideStyleType: SlideStyleType;
    payload: ModulePayload;
    insertAfterSlideId?: string;
  }): Promise<string> {
    const { slideStyleType, payload, insertAfterSlideId } = params;

    // 1. Calculate insertion index if requested
    let insertIndex: number | undefined = undefined;
    if (insertAfterSlideId) {
      const deck = this.yjs.exportToJSON();
      const prevIdx = deck.slides.findIndex(s => s.id === insertAfterSlideId);
      if (prevIdx !== -1) insertIndex = prevIdx + 1;
    }

    // 2. Add Slide (Transaction managed inside DeckYjsAdapter)
    const slideId = this.yjs.addSlide(slideStyleType, insertIndex);

    // 3. Map payload to predefined skeleton slots
    // Rules: Match element IDs generated by spawnElements()
    this.yjs.transact(() => {
      const deck = this.yjs.exportToJSON();
      const slide = deck.slides.find(s => s.id === slideId);
      if (!slide) return;

      // Title/Main Text mapping
      if (payload.text) {
        const textTargets = ['title', 'conceptText', 'sloganText', 'centeredTitle', 'scriptText', 'body', 'label'];
        const el = slide.elements.find(e => textTargets.includes(e.id));
        if (el) this.yjs.updateTextContent(el.id, payload.text);
      }

      // Image mapping
      if (payload.imageUrl) {
        const imageTargets = ['imageMain', 'bgImage', 'visualFull', 'lockedPlaceholder'];
        const el = slide.elements.find(e => imageTargets.includes(e.id));
        if (el) this.yjs.replaceMediaSource(el.id, payload.imageUrl);
      }

      // Handle arrays (texts/images) for grid-based slides (Storyboard, DirectionBoard)
      if (payload.texts && payload.texts.length > 0) {
        payload.texts.forEach((txt, idx) => {
          // Attempt to find numbered slots (sb-desc-0, sb-desc-1, etc.)
          const targets = [`sb-desc-${idx}`, `db-cap-${idx}`, `pillar-txt-${idx}`];
          const el = slide.elements.find(e => targets.includes(e.id));
          if (el) this.yjs.updateTextContent(el.id, txt);
        });
      }

      if (payload.images && payload.images.length > 0) {
        payload.images.forEach((img, idx) => {
          const targets = [`sb-img-${idx}`, `db-img-${idx}`, `ref-img-${idx}`];
          const el = slide.elements.find(e => targets.includes(e.id));
          if (el) this.yjs.replaceMediaSource(el.id, img);
        });
      }
    });

    return slideId;
  }

  /**
   * Intent: Update existing slide elements.
   */
  public async updateSlideContent(params: {
    slideId: string;
    contentPatch: ContentPatch[];
  }): Promise<void> {
    this.yjs.transact(() => {
      params.contentPatch.forEach(patch => {
        if (patch.type === 'TEXT') {
          this.yjs.updateTextContent(patch.elementId, patch.value);
        } else if (patch.type === 'IMAGE') {
          this.yjs.replaceMediaSource(patch.elementId, patch.value);
        }
      });
    });
  }
}
